## Pending Vote Logic Flaw Enables Risk-free Validators

Platform: Remedy
Timestamp: 12 January 2026 12:11

report has been successfully resolved!

Celo Team message:

We wanted to take a moment to express our sincere gratitude for your contribution and dedication. Your diligence and expertise played a crucial role in helping the cLabs Inc resolve the issue, and for that, we extend our heartfelt thanks.

Asset Type: Blockchain/DLT
Severity:
Code Repository: https://github.com/celo-org/celo-monorepo/blob/master/packages/protocol/contracts/governance/Election.sol
Current Status: Closed
Repository for core projects comprising the Celo platform: https://github.com/celo-org/celo-monorepo/

Severity: Informational
Link to the Repository and Line Number
https://github.com/celo-org/celo-monorepo/blob/master/packages/protocol/contracts/governance/Election.sol

## Summary
The Election and LockedGold contracts contain a critical economic security flaw. The current logic allows a malicious actor to hijack the consensus layer without maintaining the required financial liability.

## Intended Logic
The code documentation states that Pending votes should not count towards elections. They are intended to function as a waiting period before votes become active.

Election.sol

```solidity
  // Pending votes are those for which no following elections have been held.
  // These votes have yet to contribute to the election of validators and thus do not accrue
  // rewards.
  struct PendingVotes {
    // The total number of pending votes cast across all groups.
    uint256 total;
    mapping(address => GroupPendingVotes) forGroup;
  }
```

## Implementation Logic
The vote() function executes a logic contradictory to the documentation. It calls incrementTotalVotes immediately upon casting a vote. This updates the votes.total.eligible list, which electValidatorSigners uses to allocate seats via the D'Hondt method. Consequently, Pending votes function as Active votes regarding governance power immediately.

### Ref: Election.sol

```solidity
  function vote(
    address group,
    uint256 value,
    address lesser,
    address greater
  ) external nonReentrant onlyWhenNotBlocked returns (bool) {
    // ... validation checks ...

    // Adds to pending (Correct)
    incrementPendingVotes(group, account, value);

    // FAILURE: Adds to Total Eligible Votes immediately
    incrementTotalVotes(account, group, value, lesser, greater); 
    
    getLockedGold().decrementNonvotingAccountBalance(account, value);
    emit ValidatorGroupVoteCast(account, group, value);
    return true;
  }
```


this is the function that does the increment

```solidity
  function incrementTotalVotes(
    address account,
    address group,
    uint256 value,
    address lesser,
    address greater
  ) private {
    uint256 newVoteTotal = votes.total.eligible.getValue(group).add(value);
    votes.total.eligible.update(group, newVoteTotal, lesser, greater);

    if (allowedToVoteOverMaxNumberOfGroups[account]) {
      updateTotalVotesByAccountForGroup(account, group);
    }
  }

```

## The Exploit
An attacker can exploit this inconsistency to operate a validator without slashable funds.

Election Manipulation: In the final block of Epoch N, the attacker uses a large amount of capital to cast a Pending Vote for a malicious Validator Group. The protocol runs electValidatorSigners in the same block. Because vote() updated the total immediately, the malicious group wins a seat and is committed as a Validator for Epoch N+1.
Capital Retrieval: In the first block of Epoch N+1, the attacker calls revokePending() and unlock().
inside election contract, here is the revokePending():

```solidity
  function revokePending(
    address group,
    uint256 value,
    address lesser,
    address greater,
    uint256 index
  ) external nonReentrant returns (bool) {
    require(group != address(0), "Group address zero");
    address account = getAccounts().voteSignerToAccount(msg.sender);
    require(0 < value, "Vote value cannot be zero");
    require(
      value <= getPendingVotesForGroupByAccount(group, account),
      "Vote value larger than pending votes"
    );
    decrementPendingVotes(group, account, value);
    decrementTotalVotes(account, group, value, lesser, greater);
    getLockedGold().incrementNonvotingAccountBalance(account, value);
    if (getTotalVotesForGroupByAccount(group, account) == 0) {
      deleteElement(votes.groupsVotedFor[account], group, index);
    }
    emit ValidatorGroupPendingVoteRevoked(account, group, value);
    return true;
  }
```

inside LockedGold, here is unlock:

```solidity
  function unlock(uint256 value) external nonReentrant {
    require(
      getAccounts().isAccount(msg.sender),
      "Sender must be registered with Account.createAccount to lock or unlock"
    );
    Balances storage account = balances[msg.sender];

    uint256 totalLockedGold = getAccountTotalLockedGold(msg.sender);
    // Prevent unlocking CELO when voting on governance proposals so that the CELO cannot be
    // used to vote more than once.
    uint256 remainingLockedGold = totalLockedGold.sub(value);

    uint256 totalReferendumVotes = getGovernance().getAmountOfGoldUsedForVoting(msg.sender);
    require(
      remainingLockedGold >= totalReferendumVotes,
      "Not enough unlockable celo. Celo is locked in voting."
    );

    FixidityLib.Fraction memory delegatedPercentage = delegatorInfo[msg.sender]
      .totalDelegatedCeloFraction;

    if (FixidityLib.gt(delegatedPercentage, FixidityLib.newFixed(0))) {
      revokeFromDelegatedWhenUnlocking(msg.sender, value);
    }

    uint256 balanceRequirement = getValidators().getAccountLockedGoldRequirement(msg.sender);
    require(
      balanceRequirement == 0 || balanceRequirement <= remainingLockedGold,
      "Either account doesn't have enough locked Celo or locked Celo is being used for voting."
    );
    _decrementNonvotingAccountBalance(msg.sender, value);
    uint256 available = now.add(unlockingPeriod);
    // CERTORA: the slot containing the length could be MAX_UINT
    account.pendingWithdrawals.push(PendingWithdrawal(value, available));
    emit GoldUnlocked(msg.sender, value, available);
  }
```


### Slashing Bypass: 
The attacker's funds move from Non-voting Locked Gold to Pending Withdrawals. The protocol's slashing mechanism in LockedGold.sol only checks getAccountTotalLockedGold, which excludes pending withdrawals.

### Result: 
The attacker controls a Validator seat for the duration of the epoch (24 hours). If the protocol attempts to slash the validator for misbehavior, it finds zero Locked Gold.

## 4. Recommended Fix
Enforce the logic defined in the documentation. Pending votes must not impact the election eligibility list until they are explicitly activated.

Step 1: Stop counting pending votes in the election total.
Modify vote() to remove the incrementTotalVotes call.

// Election.sol

```solidity
function vote(...) ... {
    // ...
    incrementPendingVotes(group, account, value);
    
    // REMOVED: incrementTotalVotes(account, group, value, lesser, greater);
    
    getLockedGold().decrementNonvotingAccountBalance(account, value);
    emit ValidatorGroupVoteCast(account, group, value);
    return true;
}
```
Step 2: Count votes only upon activation.
Modify _activate() to apply the votes to the total eligibility list only when they convert from Pending to Active.

// Election.sol

```solidity
function _activate(address group, address account) internal onlyWhenNotBlocked returns (bool) {
    PendingVote storage pendingVote = votes.pending.forGroup[group].byAccount[account];
    require(pendingVote.epoch < getEpochNumber(), "Pending vote epoch not passed");

    uint256 value = pendingVote.value;
    require(value > 0, "Vote value cannot be zero");

    decrementPendingVotes(group, account, value);
    
    // ADDED: The vote is now active and contributes to the election.
    // Note: This requires passing lesser/greater hints or implementing re-insertion logic.
    incrementTotalVotes(account, group, value, lesser, greater); 

    uint256 units = incrementActiveVotes(group, account, value);
    emit ValidatorGroupVoteActivated(account, group, value, units);
    return true;
}
```


## Proof od Concept

```solidity

```